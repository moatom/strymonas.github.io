{
  "name": "Strymonas.GitHub.io",
  "tagline": "Stream Fusion, to Completeness",
  "body": "## Stream Fusion, to Completeness\r\n\r\n__strymonas__ is the codename of a streaming library for OCaml and Scala that offers support for fast, bulk, in-memory processing. It is developed using the state of the art facilities of Multi-Stage Programming (MSP) for each language. The utmost goal of the library is to offer a streaming API that achieves stream fusion at the highest level without altering the compiler backend. It covers the combination of many interesting (and challenging) combinators. The OCaml flavor, depends on [BER MetaOCaml](http://okmij.org/ftp/ML/MetaOCaml.html), OCaml's dialect for MSP. The Scala one depends on [scala-lms](https://scala-lms.github.io/).\r\n\r\nThe approach is described in detail in the paper _Stream Fusion, to Completeness_, that will be presented at the 44th ACM SIGPLAN Symposium on Principles of Programming Languages ([POPL'17](http://conf.researchr.org/home/POPL-2017)) in Paris.\r\n\r\n## Getting Started\r\n\r\nThe project is organized in three separate projects.\r\n\r\n1. OCaml (```/tests```, ```/benchmarks```) (clone [staged-streams.ocaml](https://github.com/strymonas/staged-streams.ocaml))\r\n1. Scala (```/tests```, ```/benchmarks```) (clone [staged-streams.scala](https://github.com/strymonas/staged-streams.scala))\r\n1. Java (```/benchmarks```) (clone [java8-benchmarks](https://github.com/strymonas/java8-benchmarks))\r\n\r\n### Prerequisites\r\n\r\nTo run each one of the three benchmark and test suites, please install the following:\r\n\r\n1. Java 8 (JVM version of at least 1.8.0 65): from your system's package manager\r\n1. Install `maven` the Apache build manager for Java projects\r\n1. OCaml: from your system's package manager\r\n1. OPAM: after you [install](https://opam.ocaml.org/doc/Install.html) OPAM you will need to initialize it  with ```opam init``` and resolve any dependencies with:\r\n\t- either the ```opam depext``` command\r\n\t- or your system's package manager (e.g., OML's dependencies)\r\n1. sbt: install following [sbt's documentation](http://www.scala-sbt.org/0.13/docs/Setup.html)\r\n\r\n### How to compile and run the benchmarks\r\n\r\n#### MetaOCaml\r\n\r\nThe following will enable MetaOCaml, install dependencies, make the project and run unit tests.\r\n\r\n```bash\r\n$ opam update\r\n$ opam switch 4.02.1+BER\r\n$ eval \"opam config env\"\r\n$ cd staging-streams.ocaml\r\n$ opam install oasis batteries.2.3.0 ounit.2.0.0 oml.0.0.5\r\n$ ./configure --enable-tests --enable-benchmarks\r\n$ make all\r\n```\r\n\r\nTo run the benchmarks via command line use the commands below:\r\n\r\n```bash\r\n$ ./benchmark_batteries.byte\r\n$ ./benchmark_stream.byte\r\n```\r\n\r\n#### LMS\r\nThe following will fire-up the sbt console, compile and run the test suite.\r\n\r\n```bash\r\n$ cd staging-streams.scala\r\n$ sbt\r\n$ test # to run the property tests or\r\n$ testOnly <name of test> # to run the property tests (tab completion works)\r\n```\r\n\r\nTo run the benchmarks via the sbt command line:\r\n\r\n```bash\r\n$ cd staging-streams.scala\r\n$ sbt\r\n$ jmh:run -i 10 -wi 10 -f1 .* # to run all benchmarks\r\n```\r\n\r\n#### Java 8\r\nTo run the benchmarks via command line:\r\n\r\n```bash\r\n$ cd java8-benchmarks\r\n$ mvn clean install\r\n$ java -Xms6g -Xmx6g -XX:-TieredCompilation -jar target/benchmarks.jar -i 10 -wi 10 -f1 .* # to run all benchmarks\r\n```\r\n\r\n## Hello World\r\n\r\nDevelopers can use our library as any other streaming/collection library. We assume the reader is familiar with: i) streaming APIs and ii) Multi-Stage Programming.\r\n\r\nFirstly, the API is similar with F#'s ```Seq``` type, Java 8's ```Stream``` API, collection APIs from OCaml and OCaml Batteries and many more. Our library supports all the core combinators for pipeline construction. Creation of streams is realized with ```of_arr``` (from arrays) and ```unfold``` (for infinite streams). We support: ```fold```, ```map```, ```filter```, ```take```, ```flat_map``` and ```zip_with```.\r\n\r\nSecondly, Multi-Stage Programming (MSP) is the core technique that this library follows. MSP is a meta-programming technique that allows a disciplined and safe form of run-time code generation. Staging, refers to the distinction of stages between compile- and run-time with more stages in-between. When more information about run-time values is available, staging can make a program profit in performance, by partially evaluating.\r\n\r\nIn staged-streams, this kind of (dynamic) information consists of the structure of the pipeline, the in-between combinators and the bodies of the lambdas used.\r\n\r\nWe prompt the user to read about MSP in the paper [A Gentle Introduction to Multi-stage Programming](https://www.cs.rice.edu/~taha/publications/journal/dspg04a.pdf), on [BER MetaOCaml](http://okmij.org/ftp/ML/MetaOCaml.html) and on [Scala-Lightweight Modular Staging (LMS)](https://scala-lms.github.io//index.html) which we use for our Scala implementation. The details of our technique and the benefits on the high level of stream fusion that is achieved, are included in the POPL17 paper.\r\n\r\n### Hello World in OCaml!\r\n\r\nIn the following example we create a simple stream from an array of six elements in OCaml using MetaOCaml's staging annotations.\r\n\r\n```ocaml\r\nopen Stream_combinators\r\n\r\nlet example =\r\n\tof_arr .<[| 0;1;2;3 |]>.\r\n      |> filter (fun x   -> .<.~x mod 2 = 0>.)\r\n      |> fold   (fun z a -> .<.~a :: .~z>.) .<[]>.\r\n\r\nRuncode.run example;;\r\n```\r\n\r\nWhen the execution reaches the ```run``` method, an optimized version of the stream will be compiled (emitted) and executed (for optimal results, native code compilation must be used using ```ocamlopt```). The resulted code will consist of a tight, for-loop.\r\n\r\n### Hello World in Scala!\r\n\r\nWith Scala LMS, the same example is demonstrated in the snippet below.\r\n\r\n```scala\r\ndef example (xs : Rep[Array[Int]]) : Rep[Int] = Stream[Int](xs)\r\n      .filter(d => d % 2 == 0)\r\n      .fold(0, ((a : Rep[Int]) => (b : Rep[Int]) => a + b))\r\n\r\nval example_s = compile(example)\r\n\r\nexample_s(Array(0, 1, 2, 3))\r\n```\r\n\r\nFor more examples see the unit directories with the unit tests for [OCaml](https://github.com/strymonas/staged-streams.ocaml/test/?at=master) and [Scala](https://github.com/strymonas/staged-streams.scala/src/test/scala/StagedStreamSpec.scala?at=master&fileviewer=file-view-default).\r\n\r\n## Bugs and Feedback\r\n\r\nTo discuss bugs, improvements and post questions please use our Github Issues.\r\n\r\n## Team\r\n\r\n- Oleg Kiselyov, [site](http://okmij.org/)\r\n- Aggelos Biboudis, [@biboudis](https://twitter.com/biboudis), [site](https://biboudis.github.io/)\r\n- Nick Palladinos, [@nickpalladinos](https://twitter.com/nickpalladinos)\r\n- Yannis Smaragdakis, [site](https://yanniss.github.io/)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}